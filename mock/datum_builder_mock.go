package mock

// Code generated by http://github.com/gojuno/minimock (3.0.6). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/aws/aws-sdk-go/service/cloudwatch"
	"github.com/gojuno/minimock/v3"
	"github.com/weareyolo/go-metrics"
)

// DatumBuilderMock implements cloudmetrics.DatumBuilder
type DatumBuilderMock struct {
	t minimock.Tester

	funcBuildCounterData          func(v metrics.Counter, name string) (mpa1 []*cloudwatch.MetricDatum)
	inspectFuncBuildCounterData   func(v metrics.Counter, name string)
	afterBuildCounterDataCounter  uint64
	beforeBuildCounterDataCounter uint64
	BuildCounterDataMock          mDatumBuilderMockBuildCounterData

	funcBuildGaugeData          func(v metrics.Gauge, name string) (mpa1 []*cloudwatch.MetricDatum)
	inspectFuncBuildGaugeData   func(v metrics.Gauge, name string)
	afterBuildGaugeDataCounter  uint64
	beforeBuildGaugeDataCounter uint64
	BuildGaugeDataMock          mDatumBuilderMockBuildGaugeData

	funcBuildGaugeFloat64Data          func(v metrics.GaugeFloat64, name string) (mpa1 []*cloudwatch.MetricDatum)
	inspectFuncBuildGaugeFloat64Data   func(v metrics.GaugeFloat64, name string)
	afterBuildGaugeFloat64DataCounter  uint64
	beforeBuildGaugeFloat64DataCounter uint64
	BuildGaugeFloat64DataMock          mDatumBuilderMockBuildGaugeFloat64Data

	funcBuildHistogramData          func(v metrics.Histogram, name string) (mpa1 []*cloudwatch.MetricDatum)
	inspectFuncBuildHistogramData   func(v metrics.Histogram, name string)
	afterBuildHistogramDataCounter  uint64
	beforeBuildHistogramDataCounter uint64
	BuildHistogramDataMock          mDatumBuilderMockBuildHistogramData

	funcBuildMeterData          func(v metrics.Meter, name string) (mpa1 []*cloudwatch.MetricDatum)
	inspectFuncBuildMeterData   func(v metrics.Meter, name string)
	afterBuildMeterDataCounter  uint64
	beforeBuildMeterDataCounter uint64
	BuildMeterDataMock          mDatumBuilderMockBuildMeterData

	funcBuildTimerData          func(v metrics.Timer, name string) (mpa1 []*cloudwatch.MetricDatum)
	inspectFuncBuildTimerData   func(v metrics.Timer, name string)
	afterBuildTimerDataCounter  uint64
	beforeBuildTimerDataCounter uint64
	BuildTimerDataMock          mDatumBuilderMockBuildTimerData
}

// NewDatumBuilderMock returns a mock for cloudmetrics.DatumBuilder
func NewDatumBuilderMock(t minimock.Tester) *DatumBuilderMock {
	m := &DatumBuilderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BuildCounterDataMock = mDatumBuilderMockBuildCounterData{mock: m}
	m.BuildCounterDataMock.callArgs = []*DatumBuilderMockBuildCounterDataParams{}

	m.BuildGaugeDataMock = mDatumBuilderMockBuildGaugeData{mock: m}
	m.BuildGaugeDataMock.callArgs = []*DatumBuilderMockBuildGaugeDataParams{}

	m.BuildGaugeFloat64DataMock = mDatumBuilderMockBuildGaugeFloat64Data{mock: m}
	m.BuildGaugeFloat64DataMock.callArgs = []*DatumBuilderMockBuildGaugeFloat64DataParams{}

	m.BuildHistogramDataMock = mDatumBuilderMockBuildHistogramData{mock: m}
	m.BuildHistogramDataMock.callArgs = []*DatumBuilderMockBuildHistogramDataParams{}

	m.BuildMeterDataMock = mDatumBuilderMockBuildMeterData{mock: m}
	m.BuildMeterDataMock.callArgs = []*DatumBuilderMockBuildMeterDataParams{}

	m.BuildTimerDataMock = mDatumBuilderMockBuildTimerData{mock: m}
	m.BuildTimerDataMock.callArgs = []*DatumBuilderMockBuildTimerDataParams{}

	return m
}

type mDatumBuilderMockBuildCounterData struct {
	mock               *DatumBuilderMock
	defaultExpectation *DatumBuilderMockBuildCounterDataExpectation
	expectations       []*DatumBuilderMockBuildCounterDataExpectation

	callArgs []*DatumBuilderMockBuildCounterDataParams
	mutex    sync.RWMutex
}

// DatumBuilderMockBuildCounterDataExpectation specifies expectation struct of the DatumBuilder.BuildCounterData
type DatumBuilderMockBuildCounterDataExpectation struct {
	mock    *DatumBuilderMock
	params  *DatumBuilderMockBuildCounterDataParams
	results *DatumBuilderMockBuildCounterDataResults
	Counter uint64
}

// DatumBuilderMockBuildCounterDataParams contains parameters of the DatumBuilder.BuildCounterData
type DatumBuilderMockBuildCounterDataParams struct {
	v    metrics.Counter
	name string
}

// DatumBuilderMockBuildCounterDataResults contains results of the DatumBuilder.BuildCounterData
type DatumBuilderMockBuildCounterDataResults struct {
	mpa1 []*cloudwatch.MetricDatum
}

// Expect sets up expected params for DatumBuilder.BuildCounterData
func (mmBuildCounterData *mDatumBuilderMockBuildCounterData) Expect(v metrics.Counter, name string) *mDatumBuilderMockBuildCounterData {
	if mmBuildCounterData.mock.funcBuildCounterData != nil {
		mmBuildCounterData.mock.t.Fatalf("DatumBuilderMock.BuildCounterData mock is already set by Set")
	}

	if mmBuildCounterData.defaultExpectation == nil {
		mmBuildCounterData.defaultExpectation = &DatumBuilderMockBuildCounterDataExpectation{}
	}

	mmBuildCounterData.defaultExpectation.params = &DatumBuilderMockBuildCounterDataParams{v, name}
	for _, e := range mmBuildCounterData.expectations {
		if minimock.Equal(e.params, mmBuildCounterData.defaultExpectation.params) {
			mmBuildCounterData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBuildCounterData.defaultExpectation.params)
		}
	}

	return mmBuildCounterData
}

// Inspect accepts an inspector function that has same arguments as the DatumBuilder.BuildCounterData
func (mmBuildCounterData *mDatumBuilderMockBuildCounterData) Inspect(f func(v metrics.Counter, name string)) *mDatumBuilderMockBuildCounterData {
	if mmBuildCounterData.mock.inspectFuncBuildCounterData != nil {
		mmBuildCounterData.mock.t.Fatalf("Inspect function is already set for DatumBuilderMock.BuildCounterData")
	}

	mmBuildCounterData.mock.inspectFuncBuildCounterData = f

	return mmBuildCounterData
}

// Return sets up results that will be returned by DatumBuilder.BuildCounterData
func (mmBuildCounterData *mDatumBuilderMockBuildCounterData) Return(mpa1 []*cloudwatch.MetricDatum) *DatumBuilderMock {
	if mmBuildCounterData.mock.funcBuildCounterData != nil {
		mmBuildCounterData.mock.t.Fatalf("DatumBuilderMock.BuildCounterData mock is already set by Set")
	}

	if mmBuildCounterData.defaultExpectation == nil {
		mmBuildCounterData.defaultExpectation = &DatumBuilderMockBuildCounterDataExpectation{mock: mmBuildCounterData.mock}
	}
	mmBuildCounterData.defaultExpectation.results = &DatumBuilderMockBuildCounterDataResults{mpa1}
	return mmBuildCounterData.mock
}

//Set uses given function f to mock the DatumBuilder.BuildCounterData method
func (mmBuildCounterData *mDatumBuilderMockBuildCounterData) Set(f func(v metrics.Counter, name string) (mpa1 []*cloudwatch.MetricDatum)) *DatumBuilderMock {
	if mmBuildCounterData.defaultExpectation != nil {
		mmBuildCounterData.mock.t.Fatalf("Default expectation is already set for the DatumBuilder.BuildCounterData method")
	}

	if len(mmBuildCounterData.expectations) > 0 {
		mmBuildCounterData.mock.t.Fatalf("Some expectations are already set for the DatumBuilder.BuildCounterData method")
	}

	mmBuildCounterData.mock.funcBuildCounterData = f
	return mmBuildCounterData.mock
}

// When sets expectation for the DatumBuilder.BuildCounterData which will trigger the result defined by the following
// Then helper
func (mmBuildCounterData *mDatumBuilderMockBuildCounterData) When(v metrics.Counter, name string) *DatumBuilderMockBuildCounterDataExpectation {
	if mmBuildCounterData.mock.funcBuildCounterData != nil {
		mmBuildCounterData.mock.t.Fatalf("DatumBuilderMock.BuildCounterData mock is already set by Set")
	}

	expectation := &DatumBuilderMockBuildCounterDataExpectation{
		mock:   mmBuildCounterData.mock,
		params: &DatumBuilderMockBuildCounterDataParams{v, name},
	}
	mmBuildCounterData.expectations = append(mmBuildCounterData.expectations, expectation)
	return expectation
}

// Then sets up DatumBuilder.BuildCounterData return parameters for the expectation previously defined by the When method
func (e *DatumBuilderMockBuildCounterDataExpectation) Then(mpa1 []*cloudwatch.MetricDatum) *DatumBuilderMock {
	e.results = &DatumBuilderMockBuildCounterDataResults{mpa1}
	return e.mock
}

// BuildCounterData implements cloudmetrics.DatumBuilder
func (mmBuildCounterData *DatumBuilderMock) BuildCounterData(v metrics.Counter, name string) (mpa1 []*cloudwatch.MetricDatum) {
	mm_atomic.AddUint64(&mmBuildCounterData.beforeBuildCounterDataCounter, 1)
	defer mm_atomic.AddUint64(&mmBuildCounterData.afterBuildCounterDataCounter, 1)

	if mmBuildCounterData.inspectFuncBuildCounterData != nil {
		mmBuildCounterData.inspectFuncBuildCounterData(v, name)
	}

	mm_params := &DatumBuilderMockBuildCounterDataParams{v, name}

	// Record call args
	mmBuildCounterData.BuildCounterDataMock.mutex.Lock()
	mmBuildCounterData.BuildCounterDataMock.callArgs = append(mmBuildCounterData.BuildCounterDataMock.callArgs, mm_params)
	mmBuildCounterData.BuildCounterDataMock.mutex.Unlock()

	for _, e := range mmBuildCounterData.BuildCounterDataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mpa1
		}
	}

	if mmBuildCounterData.BuildCounterDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuildCounterData.BuildCounterDataMock.defaultExpectation.Counter, 1)
		mm_want := mmBuildCounterData.BuildCounterDataMock.defaultExpectation.params
		mm_got := DatumBuilderMockBuildCounterDataParams{v, name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBuildCounterData.t.Errorf("DatumBuilderMock.BuildCounterData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBuildCounterData.BuildCounterDataMock.defaultExpectation.results
		if mm_results == nil {
			mmBuildCounterData.t.Fatal("No results are set for the DatumBuilderMock.BuildCounterData")
		}
		return (*mm_results).mpa1
	}
	if mmBuildCounterData.funcBuildCounterData != nil {
		return mmBuildCounterData.funcBuildCounterData(v, name)
	}
	mmBuildCounterData.t.Fatalf("Unexpected call to DatumBuilderMock.BuildCounterData. %v %v", v, name)
	return
}

// BuildCounterDataAfterCounter returns a count of finished DatumBuilderMock.BuildCounterData invocations
func (mmBuildCounterData *DatumBuilderMock) BuildCounterDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildCounterData.afterBuildCounterDataCounter)
}

// BuildCounterDataBeforeCounter returns a count of DatumBuilderMock.BuildCounterData invocations
func (mmBuildCounterData *DatumBuilderMock) BuildCounterDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildCounterData.beforeBuildCounterDataCounter)
}

// Calls returns a list of arguments used in each call to DatumBuilderMock.BuildCounterData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBuildCounterData *mDatumBuilderMockBuildCounterData) Calls() []*DatumBuilderMockBuildCounterDataParams {
	mmBuildCounterData.mutex.RLock()

	argCopy := make([]*DatumBuilderMockBuildCounterDataParams, len(mmBuildCounterData.callArgs))
	copy(argCopy, mmBuildCounterData.callArgs)

	mmBuildCounterData.mutex.RUnlock()

	return argCopy
}

// MinimockBuildCounterDataDone returns true if the count of the BuildCounterData invocations corresponds
// the number of defined expectations
func (m *DatumBuilderMock) MinimockBuildCounterDataDone() bool {
	for _, e := range m.BuildCounterDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildCounterDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildCounterDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildCounterData != nil && mm_atomic.LoadUint64(&m.afterBuildCounterDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockBuildCounterDataInspect logs each unmet expectation
func (m *DatumBuilderMock) MinimockBuildCounterDataInspect() {
	for _, e := range m.BuildCounterDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatumBuilderMock.BuildCounterData with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildCounterDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildCounterDataCounter) < 1 {
		if m.BuildCounterDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatumBuilderMock.BuildCounterData")
		} else {
			m.t.Errorf("Expected call to DatumBuilderMock.BuildCounterData with params: %#v", *m.BuildCounterDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildCounterData != nil && mm_atomic.LoadUint64(&m.afterBuildCounterDataCounter) < 1 {
		m.t.Error("Expected call to DatumBuilderMock.BuildCounterData")
	}
}

type mDatumBuilderMockBuildGaugeData struct {
	mock               *DatumBuilderMock
	defaultExpectation *DatumBuilderMockBuildGaugeDataExpectation
	expectations       []*DatumBuilderMockBuildGaugeDataExpectation

	callArgs []*DatumBuilderMockBuildGaugeDataParams
	mutex    sync.RWMutex
}

// DatumBuilderMockBuildGaugeDataExpectation specifies expectation struct of the DatumBuilder.BuildGaugeData
type DatumBuilderMockBuildGaugeDataExpectation struct {
	mock    *DatumBuilderMock
	params  *DatumBuilderMockBuildGaugeDataParams
	results *DatumBuilderMockBuildGaugeDataResults
	Counter uint64
}

// DatumBuilderMockBuildGaugeDataParams contains parameters of the DatumBuilder.BuildGaugeData
type DatumBuilderMockBuildGaugeDataParams struct {
	v    metrics.Gauge
	name string
}

// DatumBuilderMockBuildGaugeDataResults contains results of the DatumBuilder.BuildGaugeData
type DatumBuilderMockBuildGaugeDataResults struct {
	mpa1 []*cloudwatch.MetricDatum
}

// Expect sets up expected params for DatumBuilder.BuildGaugeData
func (mmBuildGaugeData *mDatumBuilderMockBuildGaugeData) Expect(v metrics.Gauge, name string) *mDatumBuilderMockBuildGaugeData {
	if mmBuildGaugeData.mock.funcBuildGaugeData != nil {
		mmBuildGaugeData.mock.t.Fatalf("DatumBuilderMock.BuildGaugeData mock is already set by Set")
	}

	if mmBuildGaugeData.defaultExpectation == nil {
		mmBuildGaugeData.defaultExpectation = &DatumBuilderMockBuildGaugeDataExpectation{}
	}

	mmBuildGaugeData.defaultExpectation.params = &DatumBuilderMockBuildGaugeDataParams{v, name}
	for _, e := range mmBuildGaugeData.expectations {
		if minimock.Equal(e.params, mmBuildGaugeData.defaultExpectation.params) {
			mmBuildGaugeData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBuildGaugeData.defaultExpectation.params)
		}
	}

	return mmBuildGaugeData
}

// Inspect accepts an inspector function that has same arguments as the DatumBuilder.BuildGaugeData
func (mmBuildGaugeData *mDatumBuilderMockBuildGaugeData) Inspect(f func(v metrics.Gauge, name string)) *mDatumBuilderMockBuildGaugeData {
	if mmBuildGaugeData.mock.inspectFuncBuildGaugeData != nil {
		mmBuildGaugeData.mock.t.Fatalf("Inspect function is already set for DatumBuilderMock.BuildGaugeData")
	}

	mmBuildGaugeData.mock.inspectFuncBuildGaugeData = f

	return mmBuildGaugeData
}

// Return sets up results that will be returned by DatumBuilder.BuildGaugeData
func (mmBuildGaugeData *mDatumBuilderMockBuildGaugeData) Return(mpa1 []*cloudwatch.MetricDatum) *DatumBuilderMock {
	if mmBuildGaugeData.mock.funcBuildGaugeData != nil {
		mmBuildGaugeData.mock.t.Fatalf("DatumBuilderMock.BuildGaugeData mock is already set by Set")
	}

	if mmBuildGaugeData.defaultExpectation == nil {
		mmBuildGaugeData.defaultExpectation = &DatumBuilderMockBuildGaugeDataExpectation{mock: mmBuildGaugeData.mock}
	}
	mmBuildGaugeData.defaultExpectation.results = &DatumBuilderMockBuildGaugeDataResults{mpa1}
	return mmBuildGaugeData.mock
}

//Set uses given function f to mock the DatumBuilder.BuildGaugeData method
func (mmBuildGaugeData *mDatumBuilderMockBuildGaugeData) Set(f func(v metrics.Gauge, name string) (mpa1 []*cloudwatch.MetricDatum)) *DatumBuilderMock {
	if mmBuildGaugeData.defaultExpectation != nil {
		mmBuildGaugeData.mock.t.Fatalf("Default expectation is already set for the DatumBuilder.BuildGaugeData method")
	}

	if len(mmBuildGaugeData.expectations) > 0 {
		mmBuildGaugeData.mock.t.Fatalf("Some expectations are already set for the DatumBuilder.BuildGaugeData method")
	}

	mmBuildGaugeData.mock.funcBuildGaugeData = f
	return mmBuildGaugeData.mock
}

// When sets expectation for the DatumBuilder.BuildGaugeData which will trigger the result defined by the following
// Then helper
func (mmBuildGaugeData *mDatumBuilderMockBuildGaugeData) When(v metrics.Gauge, name string) *DatumBuilderMockBuildGaugeDataExpectation {
	if mmBuildGaugeData.mock.funcBuildGaugeData != nil {
		mmBuildGaugeData.mock.t.Fatalf("DatumBuilderMock.BuildGaugeData mock is already set by Set")
	}

	expectation := &DatumBuilderMockBuildGaugeDataExpectation{
		mock:   mmBuildGaugeData.mock,
		params: &DatumBuilderMockBuildGaugeDataParams{v, name},
	}
	mmBuildGaugeData.expectations = append(mmBuildGaugeData.expectations, expectation)
	return expectation
}

// Then sets up DatumBuilder.BuildGaugeData return parameters for the expectation previously defined by the When method
func (e *DatumBuilderMockBuildGaugeDataExpectation) Then(mpa1 []*cloudwatch.MetricDatum) *DatumBuilderMock {
	e.results = &DatumBuilderMockBuildGaugeDataResults{mpa1}
	return e.mock
}

// BuildGaugeData implements cloudmetrics.DatumBuilder
func (mmBuildGaugeData *DatumBuilderMock) BuildGaugeData(v metrics.Gauge, name string) (mpa1 []*cloudwatch.MetricDatum) {
	mm_atomic.AddUint64(&mmBuildGaugeData.beforeBuildGaugeDataCounter, 1)
	defer mm_atomic.AddUint64(&mmBuildGaugeData.afterBuildGaugeDataCounter, 1)

	if mmBuildGaugeData.inspectFuncBuildGaugeData != nil {
		mmBuildGaugeData.inspectFuncBuildGaugeData(v, name)
	}

	mm_params := &DatumBuilderMockBuildGaugeDataParams{v, name}

	// Record call args
	mmBuildGaugeData.BuildGaugeDataMock.mutex.Lock()
	mmBuildGaugeData.BuildGaugeDataMock.callArgs = append(mmBuildGaugeData.BuildGaugeDataMock.callArgs, mm_params)
	mmBuildGaugeData.BuildGaugeDataMock.mutex.Unlock()

	for _, e := range mmBuildGaugeData.BuildGaugeDataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mpa1
		}
	}

	if mmBuildGaugeData.BuildGaugeDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuildGaugeData.BuildGaugeDataMock.defaultExpectation.Counter, 1)
		mm_want := mmBuildGaugeData.BuildGaugeDataMock.defaultExpectation.params
		mm_got := DatumBuilderMockBuildGaugeDataParams{v, name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBuildGaugeData.t.Errorf("DatumBuilderMock.BuildGaugeData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBuildGaugeData.BuildGaugeDataMock.defaultExpectation.results
		if mm_results == nil {
			mmBuildGaugeData.t.Fatal("No results are set for the DatumBuilderMock.BuildGaugeData")
		}
		return (*mm_results).mpa1
	}
	if mmBuildGaugeData.funcBuildGaugeData != nil {
		return mmBuildGaugeData.funcBuildGaugeData(v, name)
	}
	mmBuildGaugeData.t.Fatalf("Unexpected call to DatumBuilderMock.BuildGaugeData. %v %v", v, name)
	return
}

// BuildGaugeDataAfterCounter returns a count of finished DatumBuilderMock.BuildGaugeData invocations
func (mmBuildGaugeData *DatumBuilderMock) BuildGaugeDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildGaugeData.afterBuildGaugeDataCounter)
}

// BuildGaugeDataBeforeCounter returns a count of DatumBuilderMock.BuildGaugeData invocations
func (mmBuildGaugeData *DatumBuilderMock) BuildGaugeDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildGaugeData.beforeBuildGaugeDataCounter)
}

// Calls returns a list of arguments used in each call to DatumBuilderMock.BuildGaugeData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBuildGaugeData *mDatumBuilderMockBuildGaugeData) Calls() []*DatumBuilderMockBuildGaugeDataParams {
	mmBuildGaugeData.mutex.RLock()

	argCopy := make([]*DatumBuilderMockBuildGaugeDataParams, len(mmBuildGaugeData.callArgs))
	copy(argCopy, mmBuildGaugeData.callArgs)

	mmBuildGaugeData.mutex.RUnlock()

	return argCopy
}

// MinimockBuildGaugeDataDone returns true if the count of the BuildGaugeData invocations corresponds
// the number of defined expectations
func (m *DatumBuilderMock) MinimockBuildGaugeDataDone() bool {
	for _, e := range m.BuildGaugeDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildGaugeDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildGaugeDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildGaugeData != nil && mm_atomic.LoadUint64(&m.afterBuildGaugeDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockBuildGaugeDataInspect logs each unmet expectation
func (m *DatumBuilderMock) MinimockBuildGaugeDataInspect() {
	for _, e := range m.BuildGaugeDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatumBuilderMock.BuildGaugeData with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildGaugeDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildGaugeDataCounter) < 1 {
		if m.BuildGaugeDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatumBuilderMock.BuildGaugeData")
		} else {
			m.t.Errorf("Expected call to DatumBuilderMock.BuildGaugeData with params: %#v", *m.BuildGaugeDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildGaugeData != nil && mm_atomic.LoadUint64(&m.afterBuildGaugeDataCounter) < 1 {
		m.t.Error("Expected call to DatumBuilderMock.BuildGaugeData")
	}
}

type mDatumBuilderMockBuildGaugeFloat64Data struct {
	mock               *DatumBuilderMock
	defaultExpectation *DatumBuilderMockBuildGaugeFloat64DataExpectation
	expectations       []*DatumBuilderMockBuildGaugeFloat64DataExpectation

	callArgs []*DatumBuilderMockBuildGaugeFloat64DataParams
	mutex    sync.RWMutex
}

// DatumBuilderMockBuildGaugeFloat64DataExpectation specifies expectation struct of the DatumBuilder.BuildGaugeFloat64Data
type DatumBuilderMockBuildGaugeFloat64DataExpectation struct {
	mock    *DatumBuilderMock
	params  *DatumBuilderMockBuildGaugeFloat64DataParams
	results *DatumBuilderMockBuildGaugeFloat64DataResults
	Counter uint64
}

// DatumBuilderMockBuildGaugeFloat64DataParams contains parameters of the DatumBuilder.BuildGaugeFloat64Data
type DatumBuilderMockBuildGaugeFloat64DataParams struct {
	v    metrics.GaugeFloat64
	name string
}

// DatumBuilderMockBuildGaugeFloat64DataResults contains results of the DatumBuilder.BuildGaugeFloat64Data
type DatumBuilderMockBuildGaugeFloat64DataResults struct {
	mpa1 []*cloudwatch.MetricDatum
}

// Expect sets up expected params for DatumBuilder.BuildGaugeFloat64Data
func (mmBuildGaugeFloat64Data *mDatumBuilderMockBuildGaugeFloat64Data) Expect(v metrics.GaugeFloat64, name string) *mDatumBuilderMockBuildGaugeFloat64Data {
	if mmBuildGaugeFloat64Data.mock.funcBuildGaugeFloat64Data != nil {
		mmBuildGaugeFloat64Data.mock.t.Fatalf("DatumBuilderMock.BuildGaugeFloat64Data mock is already set by Set")
	}

	if mmBuildGaugeFloat64Data.defaultExpectation == nil {
		mmBuildGaugeFloat64Data.defaultExpectation = &DatumBuilderMockBuildGaugeFloat64DataExpectation{}
	}

	mmBuildGaugeFloat64Data.defaultExpectation.params = &DatumBuilderMockBuildGaugeFloat64DataParams{v, name}
	for _, e := range mmBuildGaugeFloat64Data.expectations {
		if minimock.Equal(e.params, mmBuildGaugeFloat64Data.defaultExpectation.params) {
			mmBuildGaugeFloat64Data.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBuildGaugeFloat64Data.defaultExpectation.params)
		}
	}

	return mmBuildGaugeFloat64Data
}

// Inspect accepts an inspector function that has same arguments as the DatumBuilder.BuildGaugeFloat64Data
func (mmBuildGaugeFloat64Data *mDatumBuilderMockBuildGaugeFloat64Data) Inspect(f func(v metrics.GaugeFloat64, name string)) *mDatumBuilderMockBuildGaugeFloat64Data {
	if mmBuildGaugeFloat64Data.mock.inspectFuncBuildGaugeFloat64Data != nil {
		mmBuildGaugeFloat64Data.mock.t.Fatalf("Inspect function is already set for DatumBuilderMock.BuildGaugeFloat64Data")
	}

	mmBuildGaugeFloat64Data.mock.inspectFuncBuildGaugeFloat64Data = f

	return mmBuildGaugeFloat64Data
}

// Return sets up results that will be returned by DatumBuilder.BuildGaugeFloat64Data
func (mmBuildGaugeFloat64Data *mDatumBuilderMockBuildGaugeFloat64Data) Return(mpa1 []*cloudwatch.MetricDatum) *DatumBuilderMock {
	if mmBuildGaugeFloat64Data.mock.funcBuildGaugeFloat64Data != nil {
		mmBuildGaugeFloat64Data.mock.t.Fatalf("DatumBuilderMock.BuildGaugeFloat64Data mock is already set by Set")
	}

	if mmBuildGaugeFloat64Data.defaultExpectation == nil {
		mmBuildGaugeFloat64Data.defaultExpectation = &DatumBuilderMockBuildGaugeFloat64DataExpectation{mock: mmBuildGaugeFloat64Data.mock}
	}
	mmBuildGaugeFloat64Data.defaultExpectation.results = &DatumBuilderMockBuildGaugeFloat64DataResults{mpa1}
	return mmBuildGaugeFloat64Data.mock
}

//Set uses given function f to mock the DatumBuilder.BuildGaugeFloat64Data method
func (mmBuildGaugeFloat64Data *mDatumBuilderMockBuildGaugeFloat64Data) Set(f func(v metrics.GaugeFloat64, name string) (mpa1 []*cloudwatch.MetricDatum)) *DatumBuilderMock {
	if mmBuildGaugeFloat64Data.defaultExpectation != nil {
		mmBuildGaugeFloat64Data.mock.t.Fatalf("Default expectation is already set for the DatumBuilder.BuildGaugeFloat64Data method")
	}

	if len(mmBuildGaugeFloat64Data.expectations) > 0 {
		mmBuildGaugeFloat64Data.mock.t.Fatalf("Some expectations are already set for the DatumBuilder.BuildGaugeFloat64Data method")
	}

	mmBuildGaugeFloat64Data.mock.funcBuildGaugeFloat64Data = f
	return mmBuildGaugeFloat64Data.mock
}

// When sets expectation for the DatumBuilder.BuildGaugeFloat64Data which will trigger the result defined by the following
// Then helper
func (mmBuildGaugeFloat64Data *mDatumBuilderMockBuildGaugeFloat64Data) When(v metrics.GaugeFloat64, name string) *DatumBuilderMockBuildGaugeFloat64DataExpectation {
	if mmBuildGaugeFloat64Data.mock.funcBuildGaugeFloat64Data != nil {
		mmBuildGaugeFloat64Data.mock.t.Fatalf("DatumBuilderMock.BuildGaugeFloat64Data mock is already set by Set")
	}

	expectation := &DatumBuilderMockBuildGaugeFloat64DataExpectation{
		mock:   mmBuildGaugeFloat64Data.mock,
		params: &DatumBuilderMockBuildGaugeFloat64DataParams{v, name},
	}
	mmBuildGaugeFloat64Data.expectations = append(mmBuildGaugeFloat64Data.expectations, expectation)
	return expectation
}

// Then sets up DatumBuilder.BuildGaugeFloat64Data return parameters for the expectation previously defined by the When method
func (e *DatumBuilderMockBuildGaugeFloat64DataExpectation) Then(mpa1 []*cloudwatch.MetricDatum) *DatumBuilderMock {
	e.results = &DatumBuilderMockBuildGaugeFloat64DataResults{mpa1}
	return e.mock
}

// BuildGaugeFloat64Data implements cloudmetrics.DatumBuilder
func (mmBuildGaugeFloat64Data *DatumBuilderMock) BuildGaugeFloat64Data(v metrics.GaugeFloat64, name string) (mpa1 []*cloudwatch.MetricDatum) {
	mm_atomic.AddUint64(&mmBuildGaugeFloat64Data.beforeBuildGaugeFloat64DataCounter, 1)
	defer mm_atomic.AddUint64(&mmBuildGaugeFloat64Data.afterBuildGaugeFloat64DataCounter, 1)

	if mmBuildGaugeFloat64Data.inspectFuncBuildGaugeFloat64Data != nil {
		mmBuildGaugeFloat64Data.inspectFuncBuildGaugeFloat64Data(v, name)
	}

	mm_params := &DatumBuilderMockBuildGaugeFloat64DataParams{v, name}

	// Record call args
	mmBuildGaugeFloat64Data.BuildGaugeFloat64DataMock.mutex.Lock()
	mmBuildGaugeFloat64Data.BuildGaugeFloat64DataMock.callArgs = append(mmBuildGaugeFloat64Data.BuildGaugeFloat64DataMock.callArgs, mm_params)
	mmBuildGaugeFloat64Data.BuildGaugeFloat64DataMock.mutex.Unlock()

	for _, e := range mmBuildGaugeFloat64Data.BuildGaugeFloat64DataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mpa1
		}
	}

	if mmBuildGaugeFloat64Data.BuildGaugeFloat64DataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuildGaugeFloat64Data.BuildGaugeFloat64DataMock.defaultExpectation.Counter, 1)
		mm_want := mmBuildGaugeFloat64Data.BuildGaugeFloat64DataMock.defaultExpectation.params
		mm_got := DatumBuilderMockBuildGaugeFloat64DataParams{v, name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBuildGaugeFloat64Data.t.Errorf("DatumBuilderMock.BuildGaugeFloat64Data got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBuildGaugeFloat64Data.BuildGaugeFloat64DataMock.defaultExpectation.results
		if mm_results == nil {
			mmBuildGaugeFloat64Data.t.Fatal("No results are set for the DatumBuilderMock.BuildGaugeFloat64Data")
		}
		return (*mm_results).mpa1
	}
	if mmBuildGaugeFloat64Data.funcBuildGaugeFloat64Data != nil {
		return mmBuildGaugeFloat64Data.funcBuildGaugeFloat64Data(v, name)
	}
	mmBuildGaugeFloat64Data.t.Fatalf("Unexpected call to DatumBuilderMock.BuildGaugeFloat64Data. %v %v", v, name)
	return
}

// BuildGaugeFloat64DataAfterCounter returns a count of finished DatumBuilderMock.BuildGaugeFloat64Data invocations
func (mmBuildGaugeFloat64Data *DatumBuilderMock) BuildGaugeFloat64DataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildGaugeFloat64Data.afterBuildGaugeFloat64DataCounter)
}

// BuildGaugeFloat64DataBeforeCounter returns a count of DatumBuilderMock.BuildGaugeFloat64Data invocations
func (mmBuildGaugeFloat64Data *DatumBuilderMock) BuildGaugeFloat64DataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildGaugeFloat64Data.beforeBuildGaugeFloat64DataCounter)
}

// Calls returns a list of arguments used in each call to DatumBuilderMock.BuildGaugeFloat64Data.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBuildGaugeFloat64Data *mDatumBuilderMockBuildGaugeFloat64Data) Calls() []*DatumBuilderMockBuildGaugeFloat64DataParams {
	mmBuildGaugeFloat64Data.mutex.RLock()

	argCopy := make([]*DatumBuilderMockBuildGaugeFloat64DataParams, len(mmBuildGaugeFloat64Data.callArgs))
	copy(argCopy, mmBuildGaugeFloat64Data.callArgs)

	mmBuildGaugeFloat64Data.mutex.RUnlock()

	return argCopy
}

// MinimockBuildGaugeFloat64DataDone returns true if the count of the BuildGaugeFloat64Data invocations corresponds
// the number of defined expectations
func (m *DatumBuilderMock) MinimockBuildGaugeFloat64DataDone() bool {
	for _, e := range m.BuildGaugeFloat64DataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildGaugeFloat64DataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildGaugeFloat64DataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildGaugeFloat64Data != nil && mm_atomic.LoadUint64(&m.afterBuildGaugeFloat64DataCounter) < 1 {
		return false
	}
	return true
}

// MinimockBuildGaugeFloat64DataInspect logs each unmet expectation
func (m *DatumBuilderMock) MinimockBuildGaugeFloat64DataInspect() {
	for _, e := range m.BuildGaugeFloat64DataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatumBuilderMock.BuildGaugeFloat64Data with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildGaugeFloat64DataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildGaugeFloat64DataCounter) < 1 {
		if m.BuildGaugeFloat64DataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatumBuilderMock.BuildGaugeFloat64Data")
		} else {
			m.t.Errorf("Expected call to DatumBuilderMock.BuildGaugeFloat64Data with params: %#v", *m.BuildGaugeFloat64DataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildGaugeFloat64Data != nil && mm_atomic.LoadUint64(&m.afterBuildGaugeFloat64DataCounter) < 1 {
		m.t.Error("Expected call to DatumBuilderMock.BuildGaugeFloat64Data")
	}
}

type mDatumBuilderMockBuildHistogramData struct {
	mock               *DatumBuilderMock
	defaultExpectation *DatumBuilderMockBuildHistogramDataExpectation
	expectations       []*DatumBuilderMockBuildHistogramDataExpectation

	callArgs []*DatumBuilderMockBuildHistogramDataParams
	mutex    sync.RWMutex
}

// DatumBuilderMockBuildHistogramDataExpectation specifies expectation struct of the DatumBuilder.BuildHistogramData
type DatumBuilderMockBuildHistogramDataExpectation struct {
	mock    *DatumBuilderMock
	params  *DatumBuilderMockBuildHistogramDataParams
	results *DatumBuilderMockBuildHistogramDataResults
	Counter uint64
}

// DatumBuilderMockBuildHistogramDataParams contains parameters of the DatumBuilder.BuildHistogramData
type DatumBuilderMockBuildHistogramDataParams struct {
	v    metrics.Histogram
	name string
}

// DatumBuilderMockBuildHistogramDataResults contains results of the DatumBuilder.BuildHistogramData
type DatumBuilderMockBuildHistogramDataResults struct {
	mpa1 []*cloudwatch.MetricDatum
}

// Expect sets up expected params for DatumBuilder.BuildHistogramData
func (mmBuildHistogramData *mDatumBuilderMockBuildHistogramData) Expect(v metrics.Histogram, name string) *mDatumBuilderMockBuildHistogramData {
	if mmBuildHistogramData.mock.funcBuildHistogramData != nil {
		mmBuildHistogramData.mock.t.Fatalf("DatumBuilderMock.BuildHistogramData mock is already set by Set")
	}

	if mmBuildHistogramData.defaultExpectation == nil {
		mmBuildHistogramData.defaultExpectation = &DatumBuilderMockBuildHistogramDataExpectation{}
	}

	mmBuildHistogramData.defaultExpectation.params = &DatumBuilderMockBuildHistogramDataParams{v, name}
	for _, e := range mmBuildHistogramData.expectations {
		if minimock.Equal(e.params, mmBuildHistogramData.defaultExpectation.params) {
			mmBuildHistogramData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBuildHistogramData.defaultExpectation.params)
		}
	}

	return mmBuildHistogramData
}

// Inspect accepts an inspector function that has same arguments as the DatumBuilder.BuildHistogramData
func (mmBuildHistogramData *mDatumBuilderMockBuildHistogramData) Inspect(f func(v metrics.Histogram, name string)) *mDatumBuilderMockBuildHistogramData {
	if mmBuildHistogramData.mock.inspectFuncBuildHistogramData != nil {
		mmBuildHistogramData.mock.t.Fatalf("Inspect function is already set for DatumBuilderMock.BuildHistogramData")
	}

	mmBuildHistogramData.mock.inspectFuncBuildHistogramData = f

	return mmBuildHistogramData
}

// Return sets up results that will be returned by DatumBuilder.BuildHistogramData
func (mmBuildHistogramData *mDatumBuilderMockBuildHistogramData) Return(mpa1 []*cloudwatch.MetricDatum) *DatumBuilderMock {
	if mmBuildHistogramData.mock.funcBuildHistogramData != nil {
		mmBuildHistogramData.mock.t.Fatalf("DatumBuilderMock.BuildHistogramData mock is already set by Set")
	}

	if mmBuildHistogramData.defaultExpectation == nil {
		mmBuildHistogramData.defaultExpectation = &DatumBuilderMockBuildHistogramDataExpectation{mock: mmBuildHistogramData.mock}
	}
	mmBuildHistogramData.defaultExpectation.results = &DatumBuilderMockBuildHistogramDataResults{mpa1}
	return mmBuildHistogramData.mock
}

//Set uses given function f to mock the DatumBuilder.BuildHistogramData method
func (mmBuildHistogramData *mDatumBuilderMockBuildHistogramData) Set(f func(v metrics.Histogram, name string) (mpa1 []*cloudwatch.MetricDatum)) *DatumBuilderMock {
	if mmBuildHistogramData.defaultExpectation != nil {
		mmBuildHistogramData.mock.t.Fatalf("Default expectation is already set for the DatumBuilder.BuildHistogramData method")
	}

	if len(mmBuildHistogramData.expectations) > 0 {
		mmBuildHistogramData.mock.t.Fatalf("Some expectations are already set for the DatumBuilder.BuildHistogramData method")
	}

	mmBuildHistogramData.mock.funcBuildHistogramData = f
	return mmBuildHistogramData.mock
}

// When sets expectation for the DatumBuilder.BuildHistogramData which will trigger the result defined by the following
// Then helper
func (mmBuildHistogramData *mDatumBuilderMockBuildHistogramData) When(v metrics.Histogram, name string) *DatumBuilderMockBuildHistogramDataExpectation {
	if mmBuildHistogramData.mock.funcBuildHistogramData != nil {
		mmBuildHistogramData.mock.t.Fatalf("DatumBuilderMock.BuildHistogramData mock is already set by Set")
	}

	expectation := &DatumBuilderMockBuildHistogramDataExpectation{
		mock:   mmBuildHistogramData.mock,
		params: &DatumBuilderMockBuildHistogramDataParams{v, name},
	}
	mmBuildHistogramData.expectations = append(mmBuildHistogramData.expectations, expectation)
	return expectation
}

// Then sets up DatumBuilder.BuildHistogramData return parameters for the expectation previously defined by the When method
func (e *DatumBuilderMockBuildHistogramDataExpectation) Then(mpa1 []*cloudwatch.MetricDatum) *DatumBuilderMock {
	e.results = &DatumBuilderMockBuildHistogramDataResults{mpa1}
	return e.mock
}

// BuildHistogramData implements cloudmetrics.DatumBuilder
func (mmBuildHistogramData *DatumBuilderMock) BuildHistogramData(v metrics.Histogram, name string) (mpa1 []*cloudwatch.MetricDatum) {
	mm_atomic.AddUint64(&mmBuildHistogramData.beforeBuildHistogramDataCounter, 1)
	defer mm_atomic.AddUint64(&mmBuildHistogramData.afterBuildHistogramDataCounter, 1)

	if mmBuildHistogramData.inspectFuncBuildHistogramData != nil {
		mmBuildHistogramData.inspectFuncBuildHistogramData(v, name)
	}

	mm_params := &DatumBuilderMockBuildHistogramDataParams{v, name}

	// Record call args
	mmBuildHistogramData.BuildHistogramDataMock.mutex.Lock()
	mmBuildHistogramData.BuildHistogramDataMock.callArgs = append(mmBuildHistogramData.BuildHistogramDataMock.callArgs, mm_params)
	mmBuildHistogramData.BuildHistogramDataMock.mutex.Unlock()

	for _, e := range mmBuildHistogramData.BuildHistogramDataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mpa1
		}
	}

	if mmBuildHistogramData.BuildHistogramDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuildHistogramData.BuildHistogramDataMock.defaultExpectation.Counter, 1)
		mm_want := mmBuildHistogramData.BuildHistogramDataMock.defaultExpectation.params
		mm_got := DatumBuilderMockBuildHistogramDataParams{v, name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBuildHistogramData.t.Errorf("DatumBuilderMock.BuildHistogramData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBuildHistogramData.BuildHistogramDataMock.defaultExpectation.results
		if mm_results == nil {
			mmBuildHistogramData.t.Fatal("No results are set for the DatumBuilderMock.BuildHistogramData")
		}
		return (*mm_results).mpa1
	}
	if mmBuildHistogramData.funcBuildHistogramData != nil {
		return mmBuildHistogramData.funcBuildHistogramData(v, name)
	}
	mmBuildHistogramData.t.Fatalf("Unexpected call to DatumBuilderMock.BuildHistogramData. %v %v", v, name)
	return
}

// BuildHistogramDataAfterCounter returns a count of finished DatumBuilderMock.BuildHistogramData invocations
func (mmBuildHistogramData *DatumBuilderMock) BuildHistogramDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildHistogramData.afterBuildHistogramDataCounter)
}

// BuildHistogramDataBeforeCounter returns a count of DatumBuilderMock.BuildHistogramData invocations
func (mmBuildHistogramData *DatumBuilderMock) BuildHistogramDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildHistogramData.beforeBuildHistogramDataCounter)
}

// Calls returns a list of arguments used in each call to DatumBuilderMock.BuildHistogramData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBuildHistogramData *mDatumBuilderMockBuildHistogramData) Calls() []*DatumBuilderMockBuildHistogramDataParams {
	mmBuildHistogramData.mutex.RLock()

	argCopy := make([]*DatumBuilderMockBuildHistogramDataParams, len(mmBuildHistogramData.callArgs))
	copy(argCopy, mmBuildHistogramData.callArgs)

	mmBuildHistogramData.mutex.RUnlock()

	return argCopy
}

// MinimockBuildHistogramDataDone returns true if the count of the BuildHistogramData invocations corresponds
// the number of defined expectations
func (m *DatumBuilderMock) MinimockBuildHistogramDataDone() bool {
	for _, e := range m.BuildHistogramDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildHistogramDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildHistogramDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildHistogramData != nil && mm_atomic.LoadUint64(&m.afterBuildHistogramDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockBuildHistogramDataInspect logs each unmet expectation
func (m *DatumBuilderMock) MinimockBuildHistogramDataInspect() {
	for _, e := range m.BuildHistogramDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatumBuilderMock.BuildHistogramData with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildHistogramDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildHistogramDataCounter) < 1 {
		if m.BuildHistogramDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatumBuilderMock.BuildHistogramData")
		} else {
			m.t.Errorf("Expected call to DatumBuilderMock.BuildHistogramData with params: %#v", *m.BuildHistogramDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildHistogramData != nil && mm_atomic.LoadUint64(&m.afterBuildHistogramDataCounter) < 1 {
		m.t.Error("Expected call to DatumBuilderMock.BuildHistogramData")
	}
}

type mDatumBuilderMockBuildMeterData struct {
	mock               *DatumBuilderMock
	defaultExpectation *DatumBuilderMockBuildMeterDataExpectation
	expectations       []*DatumBuilderMockBuildMeterDataExpectation

	callArgs []*DatumBuilderMockBuildMeterDataParams
	mutex    sync.RWMutex
}

// DatumBuilderMockBuildMeterDataExpectation specifies expectation struct of the DatumBuilder.BuildMeterData
type DatumBuilderMockBuildMeterDataExpectation struct {
	mock    *DatumBuilderMock
	params  *DatumBuilderMockBuildMeterDataParams
	results *DatumBuilderMockBuildMeterDataResults
	Counter uint64
}

// DatumBuilderMockBuildMeterDataParams contains parameters of the DatumBuilder.BuildMeterData
type DatumBuilderMockBuildMeterDataParams struct {
	v    metrics.Meter
	name string
}

// DatumBuilderMockBuildMeterDataResults contains results of the DatumBuilder.BuildMeterData
type DatumBuilderMockBuildMeterDataResults struct {
	mpa1 []*cloudwatch.MetricDatum
}

// Expect sets up expected params for DatumBuilder.BuildMeterData
func (mmBuildMeterData *mDatumBuilderMockBuildMeterData) Expect(v metrics.Meter, name string) *mDatumBuilderMockBuildMeterData {
	if mmBuildMeterData.mock.funcBuildMeterData != nil {
		mmBuildMeterData.mock.t.Fatalf("DatumBuilderMock.BuildMeterData mock is already set by Set")
	}

	if mmBuildMeterData.defaultExpectation == nil {
		mmBuildMeterData.defaultExpectation = &DatumBuilderMockBuildMeterDataExpectation{}
	}

	mmBuildMeterData.defaultExpectation.params = &DatumBuilderMockBuildMeterDataParams{v, name}
	for _, e := range mmBuildMeterData.expectations {
		if minimock.Equal(e.params, mmBuildMeterData.defaultExpectation.params) {
			mmBuildMeterData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBuildMeterData.defaultExpectation.params)
		}
	}

	return mmBuildMeterData
}

// Inspect accepts an inspector function that has same arguments as the DatumBuilder.BuildMeterData
func (mmBuildMeterData *mDatumBuilderMockBuildMeterData) Inspect(f func(v metrics.Meter, name string)) *mDatumBuilderMockBuildMeterData {
	if mmBuildMeterData.mock.inspectFuncBuildMeterData != nil {
		mmBuildMeterData.mock.t.Fatalf("Inspect function is already set for DatumBuilderMock.BuildMeterData")
	}

	mmBuildMeterData.mock.inspectFuncBuildMeterData = f

	return mmBuildMeterData
}

// Return sets up results that will be returned by DatumBuilder.BuildMeterData
func (mmBuildMeterData *mDatumBuilderMockBuildMeterData) Return(mpa1 []*cloudwatch.MetricDatum) *DatumBuilderMock {
	if mmBuildMeterData.mock.funcBuildMeterData != nil {
		mmBuildMeterData.mock.t.Fatalf("DatumBuilderMock.BuildMeterData mock is already set by Set")
	}

	if mmBuildMeterData.defaultExpectation == nil {
		mmBuildMeterData.defaultExpectation = &DatumBuilderMockBuildMeterDataExpectation{mock: mmBuildMeterData.mock}
	}
	mmBuildMeterData.defaultExpectation.results = &DatumBuilderMockBuildMeterDataResults{mpa1}
	return mmBuildMeterData.mock
}

//Set uses given function f to mock the DatumBuilder.BuildMeterData method
func (mmBuildMeterData *mDatumBuilderMockBuildMeterData) Set(f func(v metrics.Meter, name string) (mpa1 []*cloudwatch.MetricDatum)) *DatumBuilderMock {
	if mmBuildMeterData.defaultExpectation != nil {
		mmBuildMeterData.mock.t.Fatalf("Default expectation is already set for the DatumBuilder.BuildMeterData method")
	}

	if len(mmBuildMeterData.expectations) > 0 {
		mmBuildMeterData.mock.t.Fatalf("Some expectations are already set for the DatumBuilder.BuildMeterData method")
	}

	mmBuildMeterData.mock.funcBuildMeterData = f
	return mmBuildMeterData.mock
}

// When sets expectation for the DatumBuilder.BuildMeterData which will trigger the result defined by the following
// Then helper
func (mmBuildMeterData *mDatumBuilderMockBuildMeterData) When(v metrics.Meter, name string) *DatumBuilderMockBuildMeterDataExpectation {
	if mmBuildMeterData.mock.funcBuildMeterData != nil {
		mmBuildMeterData.mock.t.Fatalf("DatumBuilderMock.BuildMeterData mock is already set by Set")
	}

	expectation := &DatumBuilderMockBuildMeterDataExpectation{
		mock:   mmBuildMeterData.mock,
		params: &DatumBuilderMockBuildMeterDataParams{v, name},
	}
	mmBuildMeterData.expectations = append(mmBuildMeterData.expectations, expectation)
	return expectation
}

// Then sets up DatumBuilder.BuildMeterData return parameters for the expectation previously defined by the When method
func (e *DatumBuilderMockBuildMeterDataExpectation) Then(mpa1 []*cloudwatch.MetricDatum) *DatumBuilderMock {
	e.results = &DatumBuilderMockBuildMeterDataResults{mpa1}
	return e.mock
}

// BuildMeterData implements cloudmetrics.DatumBuilder
func (mmBuildMeterData *DatumBuilderMock) BuildMeterData(v metrics.Meter, name string) (mpa1 []*cloudwatch.MetricDatum) {
	mm_atomic.AddUint64(&mmBuildMeterData.beforeBuildMeterDataCounter, 1)
	defer mm_atomic.AddUint64(&mmBuildMeterData.afterBuildMeterDataCounter, 1)

	if mmBuildMeterData.inspectFuncBuildMeterData != nil {
		mmBuildMeterData.inspectFuncBuildMeterData(v, name)
	}

	mm_params := &DatumBuilderMockBuildMeterDataParams{v, name}

	// Record call args
	mmBuildMeterData.BuildMeterDataMock.mutex.Lock()
	mmBuildMeterData.BuildMeterDataMock.callArgs = append(mmBuildMeterData.BuildMeterDataMock.callArgs, mm_params)
	mmBuildMeterData.BuildMeterDataMock.mutex.Unlock()

	for _, e := range mmBuildMeterData.BuildMeterDataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mpa1
		}
	}

	if mmBuildMeterData.BuildMeterDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuildMeterData.BuildMeterDataMock.defaultExpectation.Counter, 1)
		mm_want := mmBuildMeterData.BuildMeterDataMock.defaultExpectation.params
		mm_got := DatumBuilderMockBuildMeterDataParams{v, name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBuildMeterData.t.Errorf("DatumBuilderMock.BuildMeterData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBuildMeterData.BuildMeterDataMock.defaultExpectation.results
		if mm_results == nil {
			mmBuildMeterData.t.Fatal("No results are set for the DatumBuilderMock.BuildMeterData")
		}
		return (*mm_results).mpa1
	}
	if mmBuildMeterData.funcBuildMeterData != nil {
		return mmBuildMeterData.funcBuildMeterData(v, name)
	}
	mmBuildMeterData.t.Fatalf("Unexpected call to DatumBuilderMock.BuildMeterData. %v %v", v, name)
	return
}

// BuildMeterDataAfterCounter returns a count of finished DatumBuilderMock.BuildMeterData invocations
func (mmBuildMeterData *DatumBuilderMock) BuildMeterDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildMeterData.afterBuildMeterDataCounter)
}

// BuildMeterDataBeforeCounter returns a count of DatumBuilderMock.BuildMeterData invocations
func (mmBuildMeterData *DatumBuilderMock) BuildMeterDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildMeterData.beforeBuildMeterDataCounter)
}

// Calls returns a list of arguments used in each call to DatumBuilderMock.BuildMeterData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBuildMeterData *mDatumBuilderMockBuildMeterData) Calls() []*DatumBuilderMockBuildMeterDataParams {
	mmBuildMeterData.mutex.RLock()

	argCopy := make([]*DatumBuilderMockBuildMeterDataParams, len(mmBuildMeterData.callArgs))
	copy(argCopy, mmBuildMeterData.callArgs)

	mmBuildMeterData.mutex.RUnlock()

	return argCopy
}

// MinimockBuildMeterDataDone returns true if the count of the BuildMeterData invocations corresponds
// the number of defined expectations
func (m *DatumBuilderMock) MinimockBuildMeterDataDone() bool {
	for _, e := range m.BuildMeterDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildMeterDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildMeterDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildMeterData != nil && mm_atomic.LoadUint64(&m.afterBuildMeterDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockBuildMeterDataInspect logs each unmet expectation
func (m *DatumBuilderMock) MinimockBuildMeterDataInspect() {
	for _, e := range m.BuildMeterDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatumBuilderMock.BuildMeterData with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildMeterDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildMeterDataCounter) < 1 {
		if m.BuildMeterDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatumBuilderMock.BuildMeterData")
		} else {
			m.t.Errorf("Expected call to DatumBuilderMock.BuildMeterData with params: %#v", *m.BuildMeterDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildMeterData != nil && mm_atomic.LoadUint64(&m.afterBuildMeterDataCounter) < 1 {
		m.t.Error("Expected call to DatumBuilderMock.BuildMeterData")
	}
}

type mDatumBuilderMockBuildTimerData struct {
	mock               *DatumBuilderMock
	defaultExpectation *DatumBuilderMockBuildTimerDataExpectation
	expectations       []*DatumBuilderMockBuildTimerDataExpectation

	callArgs []*DatumBuilderMockBuildTimerDataParams
	mutex    sync.RWMutex
}

// DatumBuilderMockBuildTimerDataExpectation specifies expectation struct of the DatumBuilder.BuildTimerData
type DatumBuilderMockBuildTimerDataExpectation struct {
	mock    *DatumBuilderMock
	params  *DatumBuilderMockBuildTimerDataParams
	results *DatumBuilderMockBuildTimerDataResults
	Counter uint64
}

// DatumBuilderMockBuildTimerDataParams contains parameters of the DatumBuilder.BuildTimerData
type DatumBuilderMockBuildTimerDataParams struct {
	v    metrics.Timer
	name string
}

// DatumBuilderMockBuildTimerDataResults contains results of the DatumBuilder.BuildTimerData
type DatumBuilderMockBuildTimerDataResults struct {
	mpa1 []*cloudwatch.MetricDatum
}

// Expect sets up expected params for DatumBuilder.BuildTimerData
func (mmBuildTimerData *mDatumBuilderMockBuildTimerData) Expect(v metrics.Timer, name string) *mDatumBuilderMockBuildTimerData {
	if mmBuildTimerData.mock.funcBuildTimerData != nil {
		mmBuildTimerData.mock.t.Fatalf("DatumBuilderMock.BuildTimerData mock is already set by Set")
	}

	if mmBuildTimerData.defaultExpectation == nil {
		mmBuildTimerData.defaultExpectation = &DatumBuilderMockBuildTimerDataExpectation{}
	}

	mmBuildTimerData.defaultExpectation.params = &DatumBuilderMockBuildTimerDataParams{v, name}
	for _, e := range mmBuildTimerData.expectations {
		if minimock.Equal(e.params, mmBuildTimerData.defaultExpectation.params) {
			mmBuildTimerData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBuildTimerData.defaultExpectation.params)
		}
	}

	return mmBuildTimerData
}

// Inspect accepts an inspector function that has same arguments as the DatumBuilder.BuildTimerData
func (mmBuildTimerData *mDatumBuilderMockBuildTimerData) Inspect(f func(v metrics.Timer, name string)) *mDatumBuilderMockBuildTimerData {
	if mmBuildTimerData.mock.inspectFuncBuildTimerData != nil {
		mmBuildTimerData.mock.t.Fatalf("Inspect function is already set for DatumBuilderMock.BuildTimerData")
	}

	mmBuildTimerData.mock.inspectFuncBuildTimerData = f

	return mmBuildTimerData
}

// Return sets up results that will be returned by DatumBuilder.BuildTimerData
func (mmBuildTimerData *mDatumBuilderMockBuildTimerData) Return(mpa1 []*cloudwatch.MetricDatum) *DatumBuilderMock {
	if mmBuildTimerData.mock.funcBuildTimerData != nil {
		mmBuildTimerData.mock.t.Fatalf("DatumBuilderMock.BuildTimerData mock is already set by Set")
	}

	if mmBuildTimerData.defaultExpectation == nil {
		mmBuildTimerData.defaultExpectation = &DatumBuilderMockBuildTimerDataExpectation{mock: mmBuildTimerData.mock}
	}
	mmBuildTimerData.defaultExpectation.results = &DatumBuilderMockBuildTimerDataResults{mpa1}
	return mmBuildTimerData.mock
}

//Set uses given function f to mock the DatumBuilder.BuildTimerData method
func (mmBuildTimerData *mDatumBuilderMockBuildTimerData) Set(f func(v metrics.Timer, name string) (mpa1 []*cloudwatch.MetricDatum)) *DatumBuilderMock {
	if mmBuildTimerData.defaultExpectation != nil {
		mmBuildTimerData.mock.t.Fatalf("Default expectation is already set for the DatumBuilder.BuildTimerData method")
	}

	if len(mmBuildTimerData.expectations) > 0 {
		mmBuildTimerData.mock.t.Fatalf("Some expectations are already set for the DatumBuilder.BuildTimerData method")
	}

	mmBuildTimerData.mock.funcBuildTimerData = f
	return mmBuildTimerData.mock
}

// When sets expectation for the DatumBuilder.BuildTimerData which will trigger the result defined by the following
// Then helper
func (mmBuildTimerData *mDatumBuilderMockBuildTimerData) When(v metrics.Timer, name string) *DatumBuilderMockBuildTimerDataExpectation {
	if mmBuildTimerData.mock.funcBuildTimerData != nil {
		mmBuildTimerData.mock.t.Fatalf("DatumBuilderMock.BuildTimerData mock is already set by Set")
	}

	expectation := &DatumBuilderMockBuildTimerDataExpectation{
		mock:   mmBuildTimerData.mock,
		params: &DatumBuilderMockBuildTimerDataParams{v, name},
	}
	mmBuildTimerData.expectations = append(mmBuildTimerData.expectations, expectation)
	return expectation
}

// Then sets up DatumBuilder.BuildTimerData return parameters for the expectation previously defined by the When method
func (e *DatumBuilderMockBuildTimerDataExpectation) Then(mpa1 []*cloudwatch.MetricDatum) *DatumBuilderMock {
	e.results = &DatumBuilderMockBuildTimerDataResults{mpa1}
	return e.mock
}

// BuildTimerData implements cloudmetrics.DatumBuilder
func (mmBuildTimerData *DatumBuilderMock) BuildTimerData(v metrics.Timer, name string) (mpa1 []*cloudwatch.MetricDatum) {
	mm_atomic.AddUint64(&mmBuildTimerData.beforeBuildTimerDataCounter, 1)
	defer mm_atomic.AddUint64(&mmBuildTimerData.afterBuildTimerDataCounter, 1)

	if mmBuildTimerData.inspectFuncBuildTimerData != nil {
		mmBuildTimerData.inspectFuncBuildTimerData(v, name)
	}

	mm_params := &DatumBuilderMockBuildTimerDataParams{v, name}

	// Record call args
	mmBuildTimerData.BuildTimerDataMock.mutex.Lock()
	mmBuildTimerData.BuildTimerDataMock.callArgs = append(mmBuildTimerData.BuildTimerDataMock.callArgs, mm_params)
	mmBuildTimerData.BuildTimerDataMock.mutex.Unlock()

	for _, e := range mmBuildTimerData.BuildTimerDataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mpa1
		}
	}

	if mmBuildTimerData.BuildTimerDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuildTimerData.BuildTimerDataMock.defaultExpectation.Counter, 1)
		mm_want := mmBuildTimerData.BuildTimerDataMock.defaultExpectation.params
		mm_got := DatumBuilderMockBuildTimerDataParams{v, name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBuildTimerData.t.Errorf("DatumBuilderMock.BuildTimerData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBuildTimerData.BuildTimerDataMock.defaultExpectation.results
		if mm_results == nil {
			mmBuildTimerData.t.Fatal("No results are set for the DatumBuilderMock.BuildTimerData")
		}
		return (*mm_results).mpa1
	}
	if mmBuildTimerData.funcBuildTimerData != nil {
		return mmBuildTimerData.funcBuildTimerData(v, name)
	}
	mmBuildTimerData.t.Fatalf("Unexpected call to DatumBuilderMock.BuildTimerData. %v %v", v, name)
	return
}

// BuildTimerDataAfterCounter returns a count of finished DatumBuilderMock.BuildTimerData invocations
func (mmBuildTimerData *DatumBuilderMock) BuildTimerDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildTimerData.afterBuildTimerDataCounter)
}

// BuildTimerDataBeforeCounter returns a count of DatumBuilderMock.BuildTimerData invocations
func (mmBuildTimerData *DatumBuilderMock) BuildTimerDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildTimerData.beforeBuildTimerDataCounter)
}

// Calls returns a list of arguments used in each call to DatumBuilderMock.BuildTimerData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBuildTimerData *mDatumBuilderMockBuildTimerData) Calls() []*DatumBuilderMockBuildTimerDataParams {
	mmBuildTimerData.mutex.RLock()

	argCopy := make([]*DatumBuilderMockBuildTimerDataParams, len(mmBuildTimerData.callArgs))
	copy(argCopy, mmBuildTimerData.callArgs)

	mmBuildTimerData.mutex.RUnlock()

	return argCopy
}

// MinimockBuildTimerDataDone returns true if the count of the BuildTimerData invocations corresponds
// the number of defined expectations
func (m *DatumBuilderMock) MinimockBuildTimerDataDone() bool {
	for _, e := range m.BuildTimerDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildTimerDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildTimerDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildTimerData != nil && mm_atomic.LoadUint64(&m.afterBuildTimerDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockBuildTimerDataInspect logs each unmet expectation
func (m *DatumBuilderMock) MinimockBuildTimerDataInspect() {
	for _, e := range m.BuildTimerDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatumBuilderMock.BuildTimerData with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildTimerDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildTimerDataCounter) < 1 {
		if m.BuildTimerDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatumBuilderMock.BuildTimerData")
		} else {
			m.t.Errorf("Expected call to DatumBuilderMock.BuildTimerData with params: %#v", *m.BuildTimerDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildTimerData != nil && mm_atomic.LoadUint64(&m.afterBuildTimerDataCounter) < 1 {
		m.t.Error("Expected call to DatumBuilderMock.BuildTimerData")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DatumBuilderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBuildCounterDataInspect()

		m.MinimockBuildGaugeDataInspect()

		m.MinimockBuildGaugeFloat64DataInspect()

		m.MinimockBuildHistogramDataInspect()

		m.MinimockBuildMeterDataInspect()

		m.MinimockBuildTimerDataInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DatumBuilderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DatumBuilderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBuildCounterDataDone() &&
		m.MinimockBuildGaugeDataDone() &&
		m.MinimockBuildGaugeFloat64DataDone() &&
		m.MinimockBuildHistogramDataDone() &&
		m.MinimockBuildMeterDataDone() &&
		m.MinimockBuildTimerDataDone()
}
